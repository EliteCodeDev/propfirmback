import { Injectable, NotFoundException, Logger } from '@nestjs/common';
import { promises as fs } from 'fs';
import * as path from 'path';
import { BufferApiService } from 'src/lib/buffer/buffer-api.service';
import { Account } from 'src/common/utils/account';
import { ConnectionStatusDto } from './dto/connection-data/connection.dto';
import { AccountDataDto } from './dto/account-data/data.dto';
import { SmtAccountDataTransformPipe } from './pipes/smt-account-data-transform.pipe';

@Injectable()
export class SmtApiService {
  private readonly logger = new Logger(SmtApiService.name);

  constructor(
    private readonly bufferApiService: BufferApiService,
    private readonly smtAccountDataTransformPipe: SmtAccountDataTransformPipe,
  ) {}

  /**
   * Obtiene una cuenta específica del buffer de forma thread-safe
   */
  async getAccount(login: string) {
    return this.bufferApiService.getAccount(login);
  }

  /**
   * Lista todas las cuentas del buffer de forma thread-safe
   */
  async listAccounts() {
    return this.bufferApiService.listAccounts();
  }

  /**
   * Obtiene estadísticas del buffer
   */
  async getStats() {
    return this.bufferApiService.getStats();
  }



  /**
   * Procesa datos de cuenta entrantes de SMT-API y los almacena en el buffer
   */
  async ingestAccountData(data: AccountDataDto, accountId: string) {
    const login = accountId;

    this.logger.debug(`[ingestAccountData] received SMT data for login=${login}`);

    try {
      // Transformar usando el pipe específico de SMT
      const transformedAccount = this.smtAccountDataTransformPipe.transform(data, login);
      
      // Usar el servicio genérico del buffer
      const result = await this.bufferApiService.ingestAccount(transformedAccount);
      
      // Persistir archivo específico de SMT
      await this.persistAccountDataToFile(data, login);

      this.logger.debug(
        `[ingestAccountData] successfully processed SMT login=${login}`,
      );
      return { success: true, login, result };
    } catch (error) {
      this.logger.error(
        `[ingestAccountData] error processing SMT login=${login}:`,
        error,
      );
      throw error;
    }
  }



  /**
   * Persiste los datos de cuenta de SMT en archivo
   */
  private async persistAccountDataToFile(data: AccountDataDto, login: string) {
    const filePath = path.join(
      process.cwd(),
      'data',
      'smt-accounts',
      `${login}.json`,
    );
    await fs.mkdir(path.dirname(filePath), { recursive: true });

    // Agregar el login a los datos antes de guardar
    const dataToSave = {
      login,
      timestamp: new Date().toISOString(),
      source: 'smt-api',
      ...data,
    };

    await fs.writeFile(filePath, JSON.stringify(dataToSave, null, 2));
    this.logger.debug(`[persistAccountDataToFile] saved SMT data to ${filePath}`);
  }

  /**
   * Elimina una cuenta del buffer de forma thread-safe
   */
  async deleteAccount(login: string) {
    return this.bufferApiService.deleteAccount(login);
  }

  /**
   * Maneja el estado de conexión específico de SMT-API
   */
  async connectionStatusService(data: ConnectionStatusDto) {
    const { success_process, error_process } = data;

    this.logger.debug(
      `[connectionStatusService] SMT success_process=${success_process?.length || 0} error_process=${error_process?.length || 0}`,
    );

    // Procesar cuentas exitosas
    if (success_process && success_process.length > 0) {
      for (const process of success_process) {
        this.logger.debug(
          `[connectionStatusService] processing successful SMT account=${process.account?.login}`,
        );
      }
    }

    // Procesar cuentas con errores
    if (error_process && error_process.length > 0) {
      for (const process of error_process) {
        this.logger.warn(
          `[connectionStatusService] processing error SMT account=${process.account?.login} error=${process.error}`,
        );
      }
    }

    return {
      message: 'SMT connection status processed successfully',
      status: 200,
      processed: {
        successful: success_process?.length || 0,
        errors: error_process?.length || 0,
      },
    };
  }

  async saveDataAccountService(id: string, data: AccountDataDto) {
    // const { close, open } = data.data;

    // const account = this.buffer.getBuffer(id);

    // account.setOpenPositions(open.positions);
    // account.setOpenResume(open.resume);
    // account.setClosedPositions(close.positions);
    // account.setClosedResume(close.resume);

    console.log('Data account: ', JSON.stringify(data, null, 2));

    // Provisional: guardar data en src/examples/accountData.ts
    // try {
    //   const examplesDir = path.join(process.cwd(), 'src', 'examples');
    //   const filePath = path.join(examplesDir, 'accountData.ts');

    //   await fs.mkdir(examplesDir, { recursive: true });

    //   const fileHeader = `/* Auto-generated by SmtApiService.saveDataAccountService on ${new Date().toISOString()} */\n`;
    //   const payload = { id, data };
    //   const fileBody = `export default ${JSON.stringify(payload, null, 2)} as const;\n`;

    //   await fs.writeFile(filePath, fileHeader + fileBody, 'utf8');
    //   this.logger.debug(`[saveDataAccountService] Data escrita en ${filePath}`);
    // } catch (err) {
    //   const stack = err instanceof Error ? err.stack : String(err);
    //   this.logger.error(
    //     '[saveDataAccountService] Error al escribir accountData.ts',
    //     stack,
    //   );
    // }
    return {
      message: 'Account data received',
      status: 200,
    };
  }
}
